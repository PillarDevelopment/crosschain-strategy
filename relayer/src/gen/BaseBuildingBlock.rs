#[allow(dead_code)]
mod base_building_block {
    # [rustfmt :: skip] use ethcontract as ethcontract ;
    #[doc = "Generated by `ethcontract`"]
    #[derive(Clone)]
    pub struct Contract {
        methods: Methods,
    }
    impl Contract {
        #[doc = r" Retrieves the raw contract instance used to generate the type safe"]
        #[doc = r" API for this contract."]
        pub fn raw_contract() -> &'static self::ethcontract::Contract {
            use self::ethcontract::common::artifact::truffle::TruffleLoader;
            use self::ethcontract::private::lazy_static;
            use self::ethcontract::Contract;
            lazy_static! {
                pub static ref CONTRACT: Contract = {
                    # [allow (unused_mut)] let mut contract = TruffleLoader :: new () . load_contract_from_str ("{\"contractName\":\"BaseBuildingBlock\",\"abi\":[{\"type\":\"function\",\"name\":\"getReceiveVersion\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"nativeRouter\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"submitNativeToken\",\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"closePosition\",\"inputs\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"nativeBridge\",\"inputs\":[{\"name\":\"actionData\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"remotes\",\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getSendVersion\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"pause\",\"inputs\":[],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"adjustPosition\",\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setConfig\",\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"_chainId\",\"type\":\"uint16\"},{\"name\":\"_configType\",\"type\":\"uint256\"},{\"name\":\"_config\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setNativeLZEndpoint\",\"inputs\":[{\"name\":\"_endpoint\",\"type\":\"address\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"openPosition\",\"inputs\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"positionType\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"repay\",\"inputs\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"getConfig\",\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"_chainId\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"_configType\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"withdrawNativeToken\",\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"payable\"},{\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"constant\":false,\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"setInboundConfirmations\",\"inputs\":[{\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"name\":\"confirmations\",\"type\":\"uint16\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setNativeRouter\",\"inputs\":[{\"name\":\"_new\",\"type\":\"address\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setReceiveVersion\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint16\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"unpause\",\"inputs\":[],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"backTokensToNative\",\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setBridge\",\"inputs\":[{\"name\":\"actionData\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setRemote\",\"inputs\":[{\"name\":\"chainId\",\"type\":\"uint16\"},{\"name\":\"remoteAddress\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"forceResumeReceive\",\"inputs\":[{\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setSendVersion\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint16\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setOutboundConfirmations\",\"inputs\":[{\"name\":\"remoteChainId\",\"type\":\"uint16\"},{\"name\":\"confirmations\",\"type\":\"uint16\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"borrow\",\"inputs\":[{\"name\":\"baseAsset\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"lzReceive\",\"inputs\":[{\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"name\":\"srcAddress\",\"type\":\"bytes\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"payload\",\"type\":\"bytes\"}],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"renounceOwnership\",\"inputs\":[],\"outputs\":[],\"constant\":false,\"stateMutability\":\"nonpayable\"},{\"type\":\"event\",\"name\":\"TransferredToNativeRouter\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"previousOwner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"newOwner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"RouterChanged\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":false},{\"name\":\"oldRelayer\",\"type\":\"address\",\"indexed\":false},{\"name\":\"newRelayer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Initialized\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint8\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Bridged\",\"inputs\":[{\"name\":\"receiverLZId\",\"type\":\"uint16\",\"indexed\":true},{\"name\":\"receiverAddress\",\"type\":\"address\",\"indexed\":true},{\"name\":\"stableAmount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false},{\"type\":\"receive\"},{\"type\":\"fallback\"}],\"bytecode\":\"\",\"networks\":{},\"devdoc\":{\"details\":null,\"methods\":{}},\"userdoc\":{\"details\":null,\"methods\":{}}}") . expect ("valid contract JSON") ;
                    contract
                };
            }
            &CONTRACT
        }
        #[doc = r" Creates a new contract instance with the specified `web3`"]
        #[doc = r" provider at the given `Address`."]
        #[doc = r""]
        #[doc = r" Note that this does not verify that a contract with a matching"]
        #[doc = r" `Abi` is actually deployed at the given address."]
        pub fn at<F, B, T>(
            web3: &self::ethcontract::web3::api::Web3<T>,
            address: self::ethcontract::Address,
        ) -> Self
        where
            F: std::future::Future<
                    Output = Result<self::ethcontract::json::Value, self::ethcontract::web3::Error>,
                > + Send
                + 'static,
            B: std::future::Future<
                    Output = Result<
                        Vec<Result<self::ethcontract::json::Value, self::ethcontract::web3::Error>>,
                        self::ethcontract::web3::Error,
                    >,
                > + Send
                + 'static,
            T: self::ethcontract::web3::Transport<Out = F>
                + self::ethcontract::web3::BatchTransport<Batch = B>
                + Send
                + Sync
                + 'static,
        {
            Contract::with_deployment_info(web3, address, None)
        }
        #[doc = r" Creates a new contract instance with the specified `web3` provider with"]
        #[doc = r" the given `Abi` at the given `Address` and an optional transaction hash."]
        #[doc = r" This hash is used to retrieve contract related information such as the"]
        #[doc = r" creation block (which is useful for fetching all historic events)."]
        #[doc = r""]
        #[doc = r" Note that this does not verify that a contract with a matching `Abi` is"]
        #[doc = r" actually deployed at the given address nor that the transaction hash,"]
        #[doc = r" when provided, is actually for this contract deployment."]
        pub fn with_deployment_info<F, B, T>(
            web3: &self::ethcontract::web3::api::Web3<T>,
            address: self::ethcontract::Address,
            deployment_information: Option<ethcontract::common::DeploymentInformation>,
        ) -> Self
        where
            F: std::future::Future<
                    Output = Result<self::ethcontract::json::Value, self::ethcontract::web3::Error>,
                > + Send
                + 'static,
            B: std::future::Future<
                    Output = Result<
                        Vec<Result<self::ethcontract::json::Value, self::ethcontract::web3::Error>>,
                        self::ethcontract::web3::Error,
                    >,
                > + Send
                + 'static,
            T: self::ethcontract::web3::Transport<Out = F>
                + self::ethcontract::web3::BatchTransport<Batch = B>
                + Send
                + Sync
                + 'static,
        {
            use self::ethcontract::transport::DynTransport;
            use self::ethcontract::web3::api::Web3;
            use self::ethcontract::Instance;
            let transport = DynTransport::new(web3.transport().clone());
            let web3 = Web3::new(transport);
            let abi = Self::raw_contract().abi.clone();
            let instance =
                Instance::with_deployment_info(web3, abi, address, deployment_information);
            Contract::from_raw(instance)
        }
        #[doc = r" Creates a contract from a raw instance."]
        fn from_raw(instance: self::ethcontract::dyns::DynInstance) -> Self {
            let methods = Methods { instance };
            Contract { methods }
        }
        #[doc = r" Returns the contract address being used by this instance."]
        pub fn address(&self) -> self::ethcontract::Address {
            self.raw_instance().address()
        }
        #[doc = r" Returns the deployment information of the contract"]
        #[doc = r" if it is known, `None` otherwise."]
        pub fn deployment_information(&self) -> Option<ethcontract::common::DeploymentInformation> {
            self.raw_instance().deployment_information()
        }
        #[doc = r" Returns a reference to the default method options used by this"]
        #[doc = r" contract."]
        pub fn defaults(&self) -> &self::ethcontract::contract::MethodDefaults {
            &self.raw_instance().defaults
        }
        #[doc = r" Returns a mutable reference to the default method options used"]
        #[doc = r" by this contract."]
        pub fn defaults_mut(&mut self) -> &mut self::ethcontract::contract::MethodDefaults {
            &mut self.raw_instance_mut().defaults
        }
        #[doc = r" Returns a reference to the raw runtime instance used by this"]
        #[doc = r" contract."]
        pub fn raw_instance(&self) -> &self::ethcontract::dyns::DynInstance {
            &self.methods.instance
        }
        #[doc = r" Returns a mutable reference to the raw runtime instance used by"]
        #[doc = r" this contract."]
        fn raw_instance_mut(&mut self) -> &mut self::ethcontract::dyns::DynInstance {
            &mut self.methods.instance
        }
    }
    impl std::fmt::Debug for Contract {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_tuple(stringify!(BaseBuildingBlock))
                .field(&self.address())
                .finish()
        }
    }
    impl Contract {
        #[doc = r" Returns an object that allows accessing typed method signatures."]
        pub fn signatures() -> Signatures {
            Signatures
        }
        #[doc = r" Retrieves a reference to type containing all the generated"]
        #[doc = r" contract methods. This can be used for methods where the name"]
        #[doc = r" would collide with a common method (like `at` or `deployed`)."]
        pub fn methods(&self) -> &Methods {
            &self.methods
        }
    }
    #[doc = r" Type containing signatures for all methods for generated contract type."]
    #[derive(Clone, Copy)]
    pub struct Signatures;
    impl Signatures {
        #[doc = "Returns signature for method `getReceiveVersion():(uint16)`."]
        #[allow(clippy::type_complexity)]
        pub fn get_receive_version(&self) -> self::ethcontract::contract::Signature<(), u16> {
            self::ethcontract::contract::Signature::new([207, 93, 20, 113])
        }
        #[doc = "Returns signature for method `nativeRouter():(address)`."]
        #[allow(clippy::type_complexity)]
        pub fn native_router(
            &self,
        ) -> self::ethcontract::contract::Signature<(), self::ethcontract::Address> {
            self::ethcontract::contract::Signature::new([154, 229, 138, 2])
        }
        #[doc = "Returns signature for method `submitNativeToken(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn submit_native_token(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([238, 236, 217, 186])
        }
        #[doc = "Returns signature for method `closePosition(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn close_position(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([171, 50, 244, 82])
        }
        #[doc = "Returns signature for method `nativeBridge(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn native_bridge(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::tokens::Bytes<Vec<u8>>,), ()>
        {
            self::ethcontract::contract::Signature::new([199, 4, 173, 182])
        }
        #[doc = "Returns signature for method `balanceOf(address):(uint256)`."]
        #[allow(clippy::type_complexity)]
        pub fn balance_of(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address,),
            self::ethcontract::U256,
        > {
            self::ethcontract::contract::Signature::new([112, 160, 130, 49])
        }
        #[doc = "Returns signature for method `remotes(uint16):(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn remotes(
            &self,
        ) -> self::ethcontract::contract::Signature<(u16,), self::ethcontract::tokens::Bytes<Vec<u8>>>
        {
            self::ethcontract::contract::Signature::new([157, 31, 97, 19])
        }
        #[doc = "Returns signature for method `getSendVersion():(uint16)`."]
        #[allow(clippy::type_complexity)]
        pub fn get_send_version(&self) -> self::ethcontract::contract::Signature<(), u16> {
            self::ethcontract::contract::Signature::new([84, 165, 190, 218])
        }
        #[doc = "Returns signature for method `pause()`."]
        #[allow(clippy::type_complexity)]
        pub fn pause(&self) -> self::ethcontract::contract::Signature<(), ()> {
            self::ethcontract::contract::Signature::new([132, 86, 203, 89])
        }
        #[doc = "Returns signature for method `adjustPosition(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn adjust_position(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::tokens::Bytes<Vec<u8>>,), ()>
        {
            self::ethcontract::contract::Signature::new([107, 3, 101, 195])
        }
        #[doc = "Returns signature for method `approve(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn approve(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::tokens::Bytes<Vec<u8>>,), ()>
        {
            self::ethcontract::contract::Signature::new([1, 157, 39, 41])
        }
        #[doc = "Returns signature for method `setConfig(uint16,uint16,uint256,bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_config(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (
                u16,
                u16,
                self::ethcontract::U256,
                self::ethcontract::tokens::Bytes<Vec<u8>>,
            ),
            (),
        > {
            self::ethcontract::contract::Signature::new([203, 237, 139, 156])
        }
        #[doc = "Returns signature for method `setNativeLZEndpoint(address)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_native_lz_endpoint(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::Address,), ()> {
            self::ethcontract::contract::Signature::new([112, 220, 94, 201])
        }
        #[doc = "Returns signature for method `openPosition(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn open_position(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([206, 233, 68, 99])
        }
        #[doc = "Returns signature for method `deposit(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn deposit(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::tokens::Bytes<Vec<u8>>,), ()>
        {
            self::ethcontract::contract::Signature::new([152, 177, 224, 106])
        }
        #[doc = "Returns signature for method `repay(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn repay(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([181, 97, 253, 43])
        }
        #[doc = "Returns signature for method `getConfig(uint16,uint16,address,uint256):(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn get_config(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (
                u16,
                u16,
                self::ethcontract::Address,
                self::ethcontract::U256,
            ),
            self::ethcontract::tokens::Bytes<Vec<u8>>,
        > {
            self::ethcontract::contract::Signature::new([245, 236, 189, 188])
        }
        #[doc = "Returns signature for method `withdrawNativeToken(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn withdraw_native_token(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([249, 93, 204, 10])
        }
        #[doc = "Returns signature for method `claim(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn claim(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([122, 30, 225, 192])
        }
        #[doc = "Returns signature for method `owner():(address)`."]
        #[allow(clippy::type_complexity)]
        pub fn owner(
            &self,
        ) -> self::ethcontract::contract::Signature<(), self::ethcontract::Address> {
            self::ethcontract::contract::Signature::new([141, 165, 203, 91])
        }
        #[doc = "Returns signature for method `setInboundConfirmations(uint16,uint16)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_inbound_confirmations(
            &self,
        ) -> self::ethcontract::contract::Signature<(u16, u16), ()> {
            self::ethcontract::contract::Signature::new([109, 246, 83, 113])
        }
        #[doc = "Returns signature for method `setNativeRouter(address)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_native_router(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::Address,), ()> {
            self::ethcontract::contract::Signature::new([230, 230, 169, 225])
        }
        #[doc = "Returns signature for method `setReceiveVersion(uint16)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_receive_version(&self) -> self::ethcontract::contract::Signature<(u16,), ()> {
            self::ethcontract::contract::Signature::new([16, 221, 177, 55])
        }
        #[doc = "Returns signature for method `unpause()`."]
        #[allow(clippy::type_complexity)]
        pub fn unpause(&self) -> self::ethcontract::contract::Signature<(), ()> {
            self::ethcontract::contract::Signature::new([63, 75, 168, 58])
        }
        #[doc = "Returns signature for method `backTokensToNative(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn back_tokens_to_native(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::tokens::Bytes<Vec<u8>>,), ()>
        {
            self::ethcontract::contract::Signature::new([234, 195, 197, 150])
        }
        #[doc = "Returns signature for method `setBridge(bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_bridge(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::tokens::Bytes<Vec<u8>>,), ()>
        {
            self::ethcontract::contract::Signature::new([108, 182, 254, 127])
        }
        #[doc = "Returns signature for method `transferOwnership(address)`."]
        #[allow(clippy::type_complexity)]
        pub fn transfer_ownership(
            &self,
        ) -> self::ethcontract::contract::Signature<(self::ethcontract::Address,), ()> {
            self::ethcontract::contract::Signature::new([242, 253, 227, 139])
        }
        #[doc = "Returns signature for method `setRemote(uint16,bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_remote(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (u16, self::ethcontract::tokens::Bytes<Vec<u8>>),
            (),
        > {
            self::ethcontract::contract::Signature::new([32, 205, 208, 161])
        }
        #[doc = "Returns signature for method `forceResumeReceive(uint16,bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn force_resume_receive(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (u16, self::ethcontract::tokens::Bytes<Vec<u8>>),
            (),
        > {
            self::ethcontract::contract::Signature::new([66, 214, 90, 141])
        }
        #[doc = "Returns signature for method `setSendVersion(uint16)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_send_version(&self) -> self::ethcontract::contract::Signature<(u16,), ()> {
            self::ethcontract::contract::Signature::new([7, 224, 219, 23])
        }
        #[doc = "Returns signature for method `setOutboundConfirmations(uint16,uint16)`."]
        #[allow(clippy::type_complexity)]
        pub fn set_outbound_confirmations(
            &self,
        ) -> self::ethcontract::contract::Signature<(u16, u16), ()> {
            self::ethcontract::contract::Signature::new([43, 34, 87, 220])
        }
        #[doc = "Returns signature for method `borrow(address,uint256,bool)`."]
        #[allow(clippy::type_complexity)]
        pub fn borrow(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (self::ethcontract::Address, self::ethcontract::U256, bool),
            (),
        > {
            self::ethcontract::contract::Signature::new([34, 161, 104, 240])
        }
        #[doc = "Returns signature for method `lzReceive(uint16,bytes,uint64,bytes)`."]
        #[allow(clippy::type_complexity)]
        pub fn lz_receive(
            &self,
        ) -> self::ethcontract::contract::Signature<
            (
                u16,
                self::ethcontract::tokens::Bytes<Vec<u8>>,
                u64,
                self::ethcontract::tokens::Bytes<Vec<u8>>,
            ),
            (),
        > {
            self::ethcontract::contract::Signature::new([0, 29, 53, 103])
        }
        #[doc = "Returns signature for method `renounceOwnership()`."]
        #[allow(clippy::type_complexity)]
        pub fn renounce_ownership(&self) -> self::ethcontract::contract::Signature<(), ()> {
            self::ethcontract::contract::Signature::new([113, 80, 24, 166])
        }
    }
    #[doc = r" Type containing all contract methods for generated contract type."]
    #[derive(Clone)]
    pub struct Methods {
        instance: self::ethcontract::dyns::DynInstance,
    }
    #[allow(clippy::too_many_arguments, clippy::type_complexity)]
    impl Methods {
        #[doc = "Generated by `ethcontract`"]
        pub fn get_receive_version(&self) -> self::ethcontract::dyns::DynViewMethodBuilder<u16> {
            self.instance
                .view_method([207, 93, 20, 113], ())
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn native_router(
            &self,
        ) -> self::ethcontract::dyns::DynViewMethodBuilder<self::ethcontract::Address> {
            self.instance
                .view_method([154, 229, 138, 2], ())
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn submit_native_token(
            &self,
            p0: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            p2: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([238, 236, 217, 186], (p0, amount, p2))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn close_position(
            &self,
            base_asset: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            p2: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([171, 50, 244, 82], (base_asset, amount, p2))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn native_bridge(
            &self,
            action_data: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([199, 4, 173, 182], (action_data,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn balance_of(
            &self,
            token: self::ethcontract::Address,
        ) -> self::ethcontract::dyns::DynViewMethodBuilder<self::ethcontract::U256> {
            self.instance
                .view_method([112, 160, 130, 49], (token,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn remotes(
            &self,
            p0: u16,
        ) -> self::ethcontract::dyns::DynViewMethodBuilder<self::ethcontract::tokens::Bytes<Vec<u8>>>
        {
            self.instance
                .view_method([157, 31, 97, 19], (p0,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn get_send_version(&self) -> self::ethcontract::dyns::DynViewMethodBuilder<u16> {
            self.instance
                .view_method([84, 165, 190, 218], ())
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn pause(&self) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([132, 86, 203, 89], ())
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn adjust_position(
            &self,
            data: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([107, 3, 101, 195], (data,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn approve(
            &self,
            data: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([1, 157, 39, 41], (data,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_config(
            &self,
            p0: u16,
            chain_id: u16,
            config_type: self::ethcontract::U256,
            config: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([203, 237, 139, 156], (p0, chain_id, config_type, config))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_native_lz_endpoint(
            &self,
            endpoint: self::ethcontract::Address,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([112, 220, 94, 201], (endpoint,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn open_position(
            &self,
            base_asset: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            position_type: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([206, 233, 68, 99], (base_asset, amount, position_type))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn deposit(
            &self,
            data: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([152, 177, 224, 106], (data,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn repay(
            &self,
            base_asset: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            p2: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([181, 97, 253, 43], (base_asset, amount, p2))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn get_config(
            &self,
            p0: u16,
            chain_id: u16,
            p2: self::ethcontract::Address,
            config_type: self::ethcontract::U256,
        ) -> self::ethcontract::dyns::DynViewMethodBuilder<self::ethcontract::tokens::Bytes<Vec<u8>>>
        {
            self.instance
                .view_method([245, 236, 189, 188], (p0, chain_id, p2, config_type))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn withdraw_native_token(
            &self,
            p0: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            p2: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([249, 93, 204, 10], (p0, amount, p2))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn claim(
            &self,
            p0: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            p2: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([122, 30, 225, 192], (p0, amount, p2))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn owner(
            &self,
        ) -> self::ethcontract::dyns::DynViewMethodBuilder<self::ethcontract::Address> {
            self.instance
                .view_method([141, 165, 203, 91], ())
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_inbound_confirmations(
            &self,
            remote_chain_id: u16,
            confirmations: u16,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([109, 246, 83, 113], (remote_chain_id, confirmations))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_native_router(
            &self,
            new: self::ethcontract::Address,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([230, 230, 169, 225], (new,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_receive_version(
            &self,
            version: u16,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([16, 221, 177, 55], (version,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn unpause(&self) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([63, 75, 168, 58], ())
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn back_tokens_to_native(
            &self,
            data: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([234, 195, 197, 150], (data,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_bridge(
            &self,
            action_data: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([108, 182, 254, 127], (action_data,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn transfer_ownership(
            &self,
            new_owner: self::ethcontract::Address,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([242, 253, 227, 139], (new_owner,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_remote(
            &self,
            chain_id: u16,
            remote_address: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([32, 205, 208, 161], (chain_id, remote_address))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn force_resume_receive(
            &self,
            src_chain_id: u16,
            src_address: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([66, 214, 90, 141], (src_chain_id, src_address))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_send_version(
            &self,
            version: u16,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([7, 224, 219, 23], (version,))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn set_outbound_confirmations(
            &self,
            remote_chain_id: u16,
            confirmations: u16,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([43, 34, 87, 220], (remote_chain_id, confirmations))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn borrow(
            &self,
            base_asset: self::ethcontract::Address,
            amount: self::ethcontract::U256,
            p2: bool,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([34, 161, 104, 240], (base_asset, amount, p2))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn lz_receive(
            &self,
            src_chain_id: u16,
            src_address: self::ethcontract::tokens::Bytes<Vec<u8>>,
            p2: u64,
            payload: self::ethcontract::tokens::Bytes<Vec<u8>>,
        ) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([0, 29, 53, 103], (src_chain_id, src_address, p2, payload))
                .expect("generated call")
        }
        #[doc = "Generated by `ethcontract`"]
        pub fn renounce_ownership(&self) -> self::ethcontract::dyns::DynMethodBuilder<()> {
            self.instance
                .method([113, 80, 24, 166], ())
                .expect("generated call")
        }
    }
    impl std::ops::Deref for Contract {
        type Target = Methods;
        fn deref(&self) -> &Self::Target {
            &self.methods
        }
    }
    impl Contract {
        #[doc = r" Returns a method builder to setup a call to a smart"]
        #[doc = r" contract's fallback function."]
        pub fn fallback<D>(&self, data: D) -> self::ethcontract::dyns::DynMethodBuilder<()>
        where
            D: Into<Vec<u8>>,
        {
            self.raw_instance()
                .fallback(data)
                .expect("generated fallback method")
        }
    }
    #[doc = r" Module containing all generated data models for this contract's"]
    #[doc = r" events."]
    pub mod event_data {
        use super::ethcontract;
        #[derive(Clone, Debug, Default, Eq, PartialEq)]
        pub struct TransferredToNativeRouter {
            pub token: self::ethcontract::Address,
            pub amount: self::ethcontract::U256,
        }
        impl TransferredToNativeRouter {
            #[doc = r" Retrieves the signature for the event this data corresponds to."]
            #[doc = r" This signature is the Keccak-256 hash of the ABI signature of"]
            #[doc = r" this event."]
            pub fn signature() -> self::ethcontract::H256 {
                self::ethcontract::H256([
                    203, 107, 134, 119, 160, 197, 69, 188, 127, 227, 60, 16, 49, 161, 8, 137, 74,
                    232, 238, 62, 228, 50, 216, 21, 52, 55, 131, 201, 76, 69, 226, 148,
                ])
            }
            #[doc = r" Retrieves the ABI signature for the event this data corresponds"]
            #[doc = r" to. For this event the value should always be:"]
            #[doc = r""]
            #[doc = "`TransferredToNativeRouter(address,uint256)`"]
            pub fn abi_signature() -> &'static str {
                "TransferredToNativeRouter(address,uint256)"
            }
        }
        impl self::ethcontract::tokens::Tokenize for TransferredToNativeRouter {
            fn from_token(
                token: self::ethcontract::common::abi::Token,
            ) -> Result<Self, self::ethcontract::tokens::Error> {
                let (token, amount) = self::ethcontract::tokens::Tokenize::from_token(token)?;
                Ok(TransferredToNativeRouter { token, amount })
            }
            fn into_token(self) -> self::ethcontract::common::abi::Token {
                unimplemented!("events are only decoded, not encoded")
            }
        }
        #[derive(Clone, Debug, Default, Eq, PartialEq)]
        pub struct OwnershipTransferred {
            pub previous_owner: self::ethcontract::Address,
            pub new_owner: self::ethcontract::Address,
        }
        impl OwnershipTransferred {
            #[doc = r" Retrieves the signature for the event this data corresponds to."]
            #[doc = r" This signature is the Keccak-256 hash of the ABI signature of"]
            #[doc = r" this event."]
            pub fn signature() -> self::ethcontract::H256 {
                self::ethcontract::H256([
                    139, 224, 7, 156, 83, 22, 89, 20, 19, 68, 205, 31, 208, 164, 242, 132, 25, 73,
                    127, 151, 34, 163, 218, 175, 227, 180, 24, 111, 107, 100, 87, 224,
                ])
            }
            #[doc = r" Retrieves the ABI signature for the event this data corresponds"]
            #[doc = r" to. For this event the value should always be:"]
            #[doc = r""]
            #[doc = "`OwnershipTransferred(address,address)`"]
            pub fn abi_signature() -> &'static str {
                "OwnershipTransferred(address,address)"
            }
        }
        impl self::ethcontract::tokens::Tokenize for OwnershipTransferred {
            fn from_token(
                token: self::ethcontract::common::abi::Token,
            ) -> Result<Self, self::ethcontract::tokens::Error> {
                let (previous_owner, new_owner) =
                    self::ethcontract::tokens::Tokenize::from_token(token)?;
                Ok(OwnershipTransferred {
                    previous_owner,
                    new_owner,
                })
            }
            fn into_token(self) -> self::ethcontract::common::abi::Token {
                unimplemented!("events are only decoded, not encoded")
            }
        }
        #[derive(Clone, Debug, Default, Eq, PartialEq)]
        pub struct RouterChanged {
            pub sender: self::ethcontract::Address,
            pub old_relayer: self::ethcontract::Address,
            pub new_relayer: self::ethcontract::Address,
        }
        impl RouterChanged {
            #[doc = r" Retrieves the signature for the event this data corresponds to."]
            #[doc = r" This signature is the Keccak-256 hash of the ABI signature of"]
            #[doc = r" this event."]
            pub fn signature() -> self::ethcontract::H256 {
                self::ethcontract::H256([
                    50, 204, 97, 24, 137, 57, 207, 201, 112, 168, 44, 37, 189, 108, 36, 91, 195,
                    110, 110, 102, 28, 233, 68, 202, 253, 49, 25, 17, 209, 104, 222, 224,
                ])
            }
            #[doc = r" Retrieves the ABI signature for the event this data corresponds"]
            #[doc = r" to. For this event the value should always be:"]
            #[doc = r""]
            #[doc = "`RouterChanged(address,address,address)`"]
            pub fn abi_signature() -> &'static str {
                "RouterChanged(address,address,address)"
            }
        }
        impl self::ethcontract::tokens::Tokenize for RouterChanged {
            fn from_token(
                token: self::ethcontract::common::abi::Token,
            ) -> Result<Self, self::ethcontract::tokens::Error> {
                let (sender, old_relayer, new_relayer) =
                    self::ethcontract::tokens::Tokenize::from_token(token)?;
                Ok(RouterChanged {
                    sender,
                    old_relayer,
                    new_relayer,
                })
            }
            fn into_token(self) -> self::ethcontract::common::abi::Token {
                unimplemented!("events are only decoded, not encoded")
            }
        }
        #[derive(Clone, Debug, Default, Eq, PartialEq)]
        pub struct Initialized {
            pub version: u8,
        }
        impl Initialized {
            #[doc = r" Retrieves the signature for the event this data corresponds to."]
            #[doc = r" This signature is the Keccak-256 hash of the ABI signature of"]
            #[doc = r" this event."]
            pub fn signature() -> self::ethcontract::H256 {
                self::ethcontract::H256([
                    127, 38, 184, 63, 249, 110, 31, 43, 106, 104, 47, 19, 56, 82, 246, 121, 138, 9,
                    196, 101, 218, 149, 146, 20, 96, 206, 251, 56, 71, 64, 36, 152,
                ])
            }
            #[doc = r" Retrieves the ABI signature for the event this data corresponds"]
            #[doc = r" to. For this event the value should always be:"]
            #[doc = r""]
            #[doc = "`Initialized(uint8)`"]
            pub fn abi_signature() -> &'static str {
                "Initialized(uint8)"
            }
        }
        impl self::ethcontract::tokens::Tokenize for Initialized {
            fn from_token(
                token: self::ethcontract::common::abi::Token,
            ) -> Result<Self, self::ethcontract::tokens::Error> {
                let (version,) = self::ethcontract::tokens::Tokenize::from_token(token)?;
                Ok(Initialized { version })
            }
            fn into_token(self) -> self::ethcontract::common::abi::Token {
                unimplemented!("events are only decoded, not encoded")
            }
        }
        #[derive(Clone, Debug, Default, Eq, PartialEq)]
        pub struct Bridged {
            pub receiver_lz_id: u16,
            pub receiver_address: self::ethcontract::Address,
            pub stable_amount: self::ethcontract::U256,
        }
        impl Bridged {
            #[doc = r" Retrieves the signature for the event this data corresponds to."]
            #[doc = r" This signature is the Keccak-256 hash of the ABI signature of"]
            #[doc = r" this event."]
            pub fn signature() -> self::ethcontract::H256 {
                self::ethcontract::H256([
                    128, 240, 137, 105, 159, 208, 242, 189, 43, 236, 165, 225, 79, 159, 16, 241,
                    249, 198, 107, 97, 20, 48, 164, 43, 8, 38, 254, 13, 175, 63, 34, 203,
                ])
            }
            #[doc = r" Retrieves the ABI signature for the event this data corresponds"]
            #[doc = r" to. For this event the value should always be:"]
            #[doc = r""]
            #[doc = "`Bridged(uint16,address,uint256)`"]
            pub fn abi_signature() -> &'static str {
                "Bridged(uint16,address,uint256)"
            }
        }
        impl self::ethcontract::tokens::Tokenize for Bridged {
            fn from_token(
                token: self::ethcontract::common::abi::Token,
            ) -> Result<Self, self::ethcontract::tokens::Error> {
                let (receiver_lz_id, receiver_address, stable_amount) =
                    self::ethcontract::tokens::Tokenize::from_token(token)?;
                Ok(Bridged {
                    receiver_lz_id,
                    receiver_address,
                    stable_amount,
                })
            }
            fn into_token(self) -> self::ethcontract::common::abi::Token {
                unimplemented!("events are only decoded, not encoded")
            }
        }
    }
    impl Contract {
        #[doc = r" Retrieves a handle to a type containing for creating event"]
        #[doc = r" streams for all the contract events."]
        pub fn events(&self) -> Events<'_> {
            Events {
                instance: self.raw_instance(),
            }
        }
    }
    pub struct Events<'a> {
        instance: &'a self::ethcontract::dyns::DynInstance,
    }
    impl Events<'_> {
        #[doc = r" Generated by `ethcontract`."]
        pub fn transferred_to_native_router(
            &self,
        ) -> self::event_builders::TransferredToNativeRouterBuilder {
            self::event_builders::TransferredToNativeRouterBuilder(
                self.instance
                    .event(self::ethcontract::H256([
                        203, 107, 134, 119, 160, 197, 69, 188, 127, 227, 60, 16, 49, 161, 8, 137,
                        74, 232, 238, 62, 228, 50, 216, 21, 52, 55, 131, 201, 76, 69, 226, 148,
                    ]))
                    .expect("generated event filter"),
            )
        }
        #[doc = r" Generated by `ethcontract`."]
        pub fn ownership_transferred(&self) -> self::event_builders::OwnershipTransferredBuilder {
            self::event_builders::OwnershipTransferredBuilder(
                self.instance
                    .event(self::ethcontract::H256([
                        139, 224, 7, 156, 83, 22, 89, 20, 19, 68, 205, 31, 208, 164, 242, 132, 25,
                        73, 127, 151, 34, 163, 218, 175, 227, 180, 24, 111, 107, 100, 87, 224,
                    ]))
                    .expect("generated event filter"),
            )
        }
        #[doc = r" Generated by `ethcontract`."]
        pub fn router_changed(&self) -> self::event_builders::RouterChangedBuilder {
            self::event_builders::RouterChangedBuilder(
                self.instance
                    .event(self::ethcontract::H256([
                        50, 204, 97, 24, 137, 57, 207, 201, 112, 168, 44, 37, 189, 108, 36, 91,
                        195, 110, 110, 102, 28, 233, 68, 202, 253, 49, 25, 17, 209, 104, 222, 224,
                    ]))
                    .expect("generated event filter"),
            )
        }
        #[doc = r" Generated by `ethcontract`."]
        pub fn initialized(&self) -> self::event_builders::InitializedBuilder {
            self::event_builders::InitializedBuilder(
                self.instance
                    .event(self::ethcontract::H256([
                        127, 38, 184, 63, 249, 110, 31, 43, 106, 104, 47, 19, 56, 82, 246, 121,
                        138, 9, 196, 101, 218, 149, 146, 20, 96, 206, 251, 56, 71, 64, 36, 152,
                    ]))
                    .expect("generated event filter"),
            )
        }
        #[doc = r" Generated by `ethcontract`."]
        pub fn bridged(&self) -> self::event_builders::BridgedBuilder {
            self::event_builders::BridgedBuilder(
                self.instance
                    .event(self::ethcontract::H256([
                        128, 240, 137, 105, 159, 208, 242, 189, 43, 236, 165, 225, 79, 159, 16,
                        241, 249, 198, 107, 97, 20, 48, 164, 43, 8, 38, 254, 13, 175, 63, 34, 203,
                    ]))
                    .expect("generated event filter"),
            )
        }
    }
    #[doc = r" Module containing the generated event stream builders with type safe"]
    #[doc = r" filter methods for this contract's events."]
    pub mod event_builders {
        use super::ethcontract;
        use super::event_data;
        #[doc = "A builder for creating a filtered stream of `TransferredToNativeRouter` events."]
        pub struct TransferredToNativeRouterBuilder(
            #[doc = r" The inner event builder."]
            pub  self::ethcontract::dyns::DynEventBuilder<
                self::event_data::TransferredToNativeRouter,
            >,
        );
        impl TransferredToNativeRouterBuilder {
            #[doc = r" Sets the starting block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the latest block."]
            #[allow(clippy::wrong_self_convention)]
            pub fn from_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).from_block(block);
                self
            }
            #[doc = r" Sets the last block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the streaming until the end of days."]
            #[allow(clippy::wrong_self_convention)]
            pub fn to_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).to_block(block);
                self
            }
            #[doc = r" Limits the number of events that can be retrieved by this filter."]
            #[doc = r""]
            #[doc = r" Note that this parameter is non-standard."]
            pub fn limit(mut self, value: usize) -> Self {
                self.0 = (self.0).limit(value);
                self
            }
            #[doc = r" Sets the polling interval. This is used as the interval between"]
            #[doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."]
            pub fn poll_interval(mut self, value: std::time::Duration) -> Self {
                self.0 = (self.0).poll_interval(value);
                self
            }
            #[doc = r" Returns a future that resolves with a collection of all existing"]
            #[doc = r" logs matching the builder parameters."]
            pub async fn query(
                self,
            ) -> std::result::Result<
                std::vec::Vec<
                    self::ethcontract::Event<self::event_data::TransferredToNativeRouter>,
                >,
                self::ethcontract::errors::EventError,
            > {
                (self.0).query().await
            }
            #[doc = r" Creates an event stream from the current event builder."]
            pub fn stream(
                self,
            ) -> impl self::ethcontract::futures::stream::Stream<
                Item = std::result::Result<
                    self::ethcontract::StreamEvent<self::event_data::TransferredToNativeRouter>,
                    self::ethcontract::errors::EventError,
                >,
            > {
                (self.0).stream()
            }
        }
        #[doc = "A builder for creating a filtered stream of `OwnershipTransferred` events."]
        pub struct OwnershipTransferredBuilder(
            #[doc = r" The inner event builder."]
            pub  self::ethcontract::dyns::DynEventBuilder<self::event_data::OwnershipTransferred>,
        );
        impl OwnershipTransferredBuilder {
            #[doc = r" Sets the starting block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the latest block."]
            #[allow(clippy::wrong_self_convention)]
            pub fn from_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).from_block(block);
                self
            }
            #[doc = r" Sets the last block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the streaming until the end of days."]
            #[allow(clippy::wrong_self_convention)]
            pub fn to_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).to_block(block);
                self
            }
            #[doc = r" Limits the number of events that can be retrieved by this filter."]
            #[doc = r""]
            #[doc = r" Note that this parameter is non-standard."]
            pub fn limit(mut self, value: usize) -> Self {
                self.0 = (self.0).limit(value);
                self
            }
            #[doc = r" Sets the polling interval. This is used as the interval between"]
            #[doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."]
            pub fn poll_interval(mut self, value: std::time::Duration) -> Self {
                self.0 = (self.0).poll_interval(value);
                self
            }
            #[doc = "Adds a filter for the previousOwner event parameter."]
            pub fn previous_owner(
                mut self,
                topic: self::ethcontract::Topic<self::ethcontract::Address>,
            ) -> Self {
                self.0 = (self.0).topic0(topic);
                self
            }
            #[doc = "Adds a filter for the newOwner event parameter."]
            pub fn new_owner(
                mut self,
                topic: self::ethcontract::Topic<self::ethcontract::Address>,
            ) -> Self {
                self.0 = (self.0).topic1(topic);
                self
            }
            #[doc = r" Returns a future that resolves with a collection of all existing"]
            #[doc = r" logs matching the builder parameters."]
            pub async fn query(
                self,
            ) -> std::result::Result<
                std::vec::Vec<self::ethcontract::Event<self::event_data::OwnershipTransferred>>,
                self::ethcontract::errors::EventError,
            > {
                (self.0).query().await
            }
            #[doc = r" Creates an event stream from the current event builder."]
            pub fn stream(
                self,
            ) -> impl self::ethcontract::futures::stream::Stream<
                Item = std::result::Result<
                    self::ethcontract::StreamEvent<self::event_data::OwnershipTransferred>,
                    self::ethcontract::errors::EventError,
                >,
            > {
                (self.0).stream()
            }
        }
        #[doc = "A builder for creating a filtered stream of `RouterChanged` events."]
        pub struct RouterChangedBuilder(
            #[doc = r" The inner event builder."]
            pub  self::ethcontract::dyns::DynEventBuilder<self::event_data::RouterChanged>,
        );
        impl RouterChangedBuilder {
            #[doc = r" Sets the starting block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the latest block."]
            #[allow(clippy::wrong_self_convention)]
            pub fn from_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).from_block(block);
                self
            }
            #[doc = r" Sets the last block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the streaming until the end of days."]
            #[allow(clippy::wrong_self_convention)]
            pub fn to_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).to_block(block);
                self
            }
            #[doc = r" Limits the number of events that can be retrieved by this filter."]
            #[doc = r""]
            #[doc = r" Note that this parameter is non-standard."]
            pub fn limit(mut self, value: usize) -> Self {
                self.0 = (self.0).limit(value);
                self
            }
            #[doc = r" Sets the polling interval. This is used as the interval between"]
            #[doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."]
            pub fn poll_interval(mut self, value: std::time::Duration) -> Self {
                self.0 = (self.0).poll_interval(value);
                self
            }
            #[doc = r" Returns a future that resolves with a collection of all existing"]
            #[doc = r" logs matching the builder parameters."]
            pub async fn query(
                self,
            ) -> std::result::Result<
                std::vec::Vec<self::ethcontract::Event<self::event_data::RouterChanged>>,
                self::ethcontract::errors::EventError,
            > {
                (self.0).query().await
            }
            #[doc = r" Creates an event stream from the current event builder."]
            pub fn stream(
                self,
            ) -> impl self::ethcontract::futures::stream::Stream<
                Item = std::result::Result<
                    self::ethcontract::StreamEvent<self::event_data::RouterChanged>,
                    self::ethcontract::errors::EventError,
                >,
            > {
                (self.0).stream()
            }
        }
        #[doc = "A builder for creating a filtered stream of `Initialized` events."]
        pub struct InitializedBuilder(
            #[doc = r" The inner event builder."]
            pub  self::ethcontract::dyns::DynEventBuilder<self::event_data::Initialized>,
        );
        impl InitializedBuilder {
            #[doc = r" Sets the starting block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the latest block."]
            #[allow(clippy::wrong_self_convention)]
            pub fn from_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).from_block(block);
                self
            }
            #[doc = r" Sets the last block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the streaming until the end of days."]
            #[allow(clippy::wrong_self_convention)]
            pub fn to_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).to_block(block);
                self
            }
            #[doc = r" Limits the number of events that can be retrieved by this filter."]
            #[doc = r""]
            #[doc = r" Note that this parameter is non-standard."]
            pub fn limit(mut self, value: usize) -> Self {
                self.0 = (self.0).limit(value);
                self
            }
            #[doc = r" Sets the polling interval. This is used as the interval between"]
            #[doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."]
            pub fn poll_interval(mut self, value: std::time::Duration) -> Self {
                self.0 = (self.0).poll_interval(value);
                self
            }
            #[doc = r" Returns a future that resolves with a collection of all existing"]
            #[doc = r" logs matching the builder parameters."]
            pub async fn query(
                self,
            ) -> std::result::Result<
                std::vec::Vec<self::ethcontract::Event<self::event_data::Initialized>>,
                self::ethcontract::errors::EventError,
            > {
                (self.0).query().await
            }
            #[doc = r" Creates an event stream from the current event builder."]
            pub fn stream(
                self,
            ) -> impl self::ethcontract::futures::stream::Stream<
                Item = std::result::Result<
                    self::ethcontract::StreamEvent<self::event_data::Initialized>,
                    self::ethcontract::errors::EventError,
                >,
            > {
                (self.0).stream()
            }
        }
        #[doc = "A builder for creating a filtered stream of `Bridged` events."]
        pub struct BridgedBuilder(
            #[doc = r" The inner event builder."]
            pub  self::ethcontract::dyns::DynEventBuilder<self::event_data::Bridged>,
        );
        impl BridgedBuilder {
            #[doc = r" Sets the starting block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the latest block."]
            #[allow(clippy::wrong_self_convention)]
            pub fn from_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).from_block(block);
                self
            }
            #[doc = r" Sets the last block from which to stream logs for."]
            #[doc = r""]
            #[doc = r" If left unset defaults to the streaming until the end of days."]
            #[allow(clippy::wrong_self_convention)]
            pub fn to_block(mut self, block: self::ethcontract::BlockNumber) -> Self {
                self.0 = (self.0).to_block(block);
                self
            }
            #[doc = r" Limits the number of events that can be retrieved by this filter."]
            #[doc = r""]
            #[doc = r" Note that this parameter is non-standard."]
            pub fn limit(mut self, value: usize) -> Self {
                self.0 = (self.0).limit(value);
                self
            }
            #[doc = r" Sets the polling interval. This is used as the interval between"]
            #[doc = r" consecutive `eth_getFilterChanges` calls to get filter updates."]
            pub fn poll_interval(mut self, value: std::time::Duration) -> Self {
                self.0 = (self.0).poll_interval(value);
                self
            }
            #[doc = "Adds a filter for the receiverLZId event parameter."]
            pub fn receiver_lz_id(mut self, topic: self::ethcontract::Topic<u16>) -> Self {
                self.0 = (self.0).topic0(topic);
                self
            }
            #[doc = "Adds a filter for the receiverAddress event parameter."]
            pub fn receiver_address(
                mut self,
                topic: self::ethcontract::Topic<self::ethcontract::Address>,
            ) -> Self {
                self.0 = (self.0).topic1(topic);
                self
            }
            #[doc = r" Returns a future that resolves with a collection of all existing"]
            #[doc = r" logs matching the builder parameters."]
            pub async fn query(
                self,
            ) -> std::result::Result<
                std::vec::Vec<self::ethcontract::Event<self::event_data::Bridged>>,
                self::ethcontract::errors::EventError,
            > {
                (self.0).query().await
            }
            #[doc = r" Creates an event stream from the current event builder."]
            pub fn stream(
                self,
            ) -> impl self::ethcontract::futures::stream::Stream<
                Item = std::result::Result<
                    self::ethcontract::StreamEvent<self::event_data::Bridged>,
                    self::ethcontract::errors::EventError,
                >,
            > {
                (self.0).stream()
            }
        }
    }
    impl Contract {
        #[doc = r" Returns a log stream with all events."]
        pub fn all_events(&self) -> self::ethcontract::dyns::DynAllEventsBuilder<Event> {
            self::ethcontract::dyns::DynAllEventsBuilder::new(
                self.raw_instance().web3(),
                self.address(),
                self.deployment_information(),
            )
        }
    }
    #[doc = r" A contract event."]
    #[derive(Clone, Debug, Eq, PartialEq)]
    pub enum Event {
        Bridged(self::event_data::Bridged),
        Initialized(self::event_data::Initialized),
        OwnershipTransferred(self::event_data::OwnershipTransferred),
        RouterChanged(self::event_data::RouterChanged),
        TransferredToNativeRouter(self::event_data::TransferredToNativeRouter),
    }
    impl self::ethcontract::contract::ParseLog for Event {
        fn parse_log(
            log: self::ethcontract::RawLog,
        ) -> Result<Self, self::ethcontract::errors::ExecutionError> {
            let standard_event = log . topics . get (0) . copied () . map (| topic | match topic { self :: ethcontract :: H256 ([128 , 240 , 137 , 105 , 159 , 208 , 242 , 189 , 43 , 236 , 165 , 225 , 79 , 159 , 16 , 241 , 249 , 198 , 107 , 97 , 20 , 48 , 164 , 43 , 8 , 38 , 254 , 13 , 175 , 63 , 34 , 203]) => Ok (Event :: Bridged (log . clone () . decode (Contract :: raw_contract () . abi . event ("Bridged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([127 , 38 , 184 , 63 , 249 , 110 , 31 , 43 , 106 , 104 , 47 , 19 , 56 , 82 , 246 , 121 , 138 , 9 , 196 , 101 , 218 , 149 , 146 , 20 , 96 , 206 , 251 , 56 , 71 , 64 , 36 , 152]) => Ok (Event :: Initialized (log . clone () . decode (Contract :: raw_contract () . abi . event ("Initialized") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([139 , 224 , 7 , 156 , 83 , 22 , 89 , 20 , 19 , 68 , 205 , 31 , 208 , 164 , 242 , 132 , 25 , 73 , 127 , 151 , 34 , 163 , 218 , 175 , 227 , 180 , 24 , 111 , 107 , 100 , 87 , 224]) => Ok (Event :: OwnershipTransferred (log . clone () . decode (Contract :: raw_contract () . abi . event ("OwnershipTransferred") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([50 , 204 , 97 , 24 , 137 , 57 , 207 , 201 , 112 , 168 , 44 , 37 , 189 , 108 , 36 , 91 , 195 , 110 , 110 , 102 , 28 , 233 , 68 , 202 , 253 , 49 , 25 , 17 , 209 , 104 , 222 , 224]) => Ok (Event :: RouterChanged (log . clone () . decode (Contract :: raw_contract () . abi . event ("RouterChanged") . expect ("generated event decode")) ?)) , self :: ethcontract :: H256 ([203 , 107 , 134 , 119 , 160 , 197 , 69 , 188 , 127 , 227 , 60 , 16 , 49 , 161 , 8 , 137 , 74 , 232 , 238 , 62 , 228 , 50 , 216 , 21 , 52 , 55 , 131 , 201 , 76 , 69 , 226 , 148]) => Ok (Event :: TransferredToNativeRouter (log . clone () . decode (Contract :: raw_contract () . abi . event ("TransferredToNativeRouter") . expect ("generated event decode")) ?)) , _ => Err (self :: ethcontract :: errors :: ExecutionError :: from (self :: ethcontract :: common :: abi :: Error :: InvalidData)) , }) ;
            if let Some(Ok(data)) = standard_event {
                return Ok(data);
            }
            Err(self::ethcontract::errors::ExecutionError::from(
                self::ethcontract::common::abi::Error::InvalidData,
            ))
        }
    }
}
use self::base_building_block::Contract as BaseBuildingBlock;
